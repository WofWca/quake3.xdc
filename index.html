<!DOCTYPE html><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark">
<title>Quake III Arena Demo</title>
<style>
html, body { margin: 0; padding: 0; overflow: hidden; background: rgb(0, 0, 0);
    font-family: "Antonio", sans-serif;
    font-optical-sizing: auto;
    font-weight: 700;
    font-style: normal;
    letter-spacing: -.05ch;
}
canvas { max-width: 100%; max-height: 100%; min-width: 100%; min-height: 100%; object-fit: contain; }
#progress { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; width: 80%; height: 4em; background: black; border: .5em solid white; padding: .5em; }
#blocker {
    position: absolute;
    top: 0;

    bottom: 0;
    left: 0;
    right: 0;
    background: transparent;
    color: white;
    user-select: none;
    -webkit-user-select: none;
}
#upload-game-files {
    color: white;
}
#ui {
    padding: 1em;
    position: absolute;
    left: 0;
    bottom: 0;
    background: transparent;
    color: rgb(197, 0, 0);
    transform-origin: bottom left;
    transform: scale(4) scaleY(0.6);
    user-select: none;
    -webkit-user-select: none;
}

.button::before,
.button::after {
    content:attr(title);
    display:block;
    position:absolute;
    top:0;
    left:0;
    bottom:0;
    right:0;
    padding: .2em
}

.button::before {
    color: rgb(200, 0, 0);
    text-shadow: .5px .5px .5px rgba(0, 0, 0, 1);
}

.selected::after, .button:hover::after {
    animation: blink .5s infinite;
    animation-timing-function: ease-in-out;
    color: rgb(255,0,0);
    text-shadow: 0 0 1px rgba(255, 0, 0, 1);
}

#ui:hover .selected:not(:hover)::after {
    animation: none;
    text-shadow: none;
}
.button {
    position: relative;
    font-family: "Antonio", sans-serif;
    font-optical-sizing: auto;
    font-weight: 700;
    font-style: normal;
    padding: .2em;
    font-weight: bold;
    color: transparent;
    background: transparent;
    text-align: center;
}

@keyframes blink {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0;
    }
}

/* .button:hover {
    color: rgb(255, 0, 0);
    text-shadow: 0 0 5px rgba(255, 0, 0, 0.8), 0 0 10px rgba(255, 0, 0, 0.6), 0 0 15px rgba(255, 0, 0, 0.4), 4px 5px  rgba(0, 0, 0, 1);
} */

#move, #look {
    width: 50%;
    height: 100%;
    top: 0;
    left: 0;
    position: absolute;
}

#look {
    /* Make 10x larger in pixel size because webkit rounds touch events to the nearest CSS pixel.
       I'm not sure if this actually works or if WebKit rounds anyway but at least we tried. */
    transform: scale(0.1);
    transform-origin: top left;
    width: 500%;
    height: 1000%;
    left: 50%;
}

#done {
    width: 100%;
    height: 100%;
    transform: scaleX(0.05);
    transform-origin: center left;
    transition: transform 5s;
    background: white; 
}
#rotator {
    transform: none;
    transform-origin: bottom left;
    position:absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    width: 100dvw;
    height: 100dvh;
    overflow:hidden;
}

@media (pointer: coarse) and (orientation: portrait) {
    #rotator {
        transform: rotate(90deg);
        transform-origin: bottom left;
        top: -100vw;
        left: 0;
        width: 100vh;
        height: 100vw;
        width: 100dvh;
        height: 100dvw;
    }
}
#blocker * { display: none; }
@media (pointer: coarse) {
    #blocker * { display: block; }
}
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Antonio:wght@100..700&display=swap" rel="stylesheet">

<body>
<div id=rotator>

<section
    id="upload-game-files"
    style="
        display: none;
        padding: 0 1rem;
        font-family: initial;
        letter-spacing: initial;
        font-weight: initial;
    "
>
    <h3>Please select game resources</h3>
    <p>
        Download demo game resources from
        <a
            href="https://archive.org/download/tucows_286139_Quake_III_Arena/linuxq3ademo-1.11-6.x86.gz.zip/linuxq3ademo-1.11-6.x86.gz.sh"
            download
        >https://archive.org/download/tucows_286139_Quake_III_Arena/linuxq3ademo-1.11-6.x86.gz.zip/linuxq3ademo-1.11-6.x86.gz.sh</a>
        and select the downloaded file below.
        <br>
        You need to paste the link into your normal browser. Clicking the link here might not work.
        <br>
        <details><summary>Alternative download</summary>
            <a href="./tucows_286139_Quake_III_Arena_archive.torrent" download>Torrent file</a>
            <br>
            You will need to unpack the .zip archive to get the <code>.gz.sh</code> file.
        </details>
    </p>
    
    <!-- Alright, let's comment this out.
    You can't really do much harm with this file.
    Normal users don't look like they know what a SHA-256 is. -->
    <!-- <p style="font-size: smaller;">
        In case you need it, the expected SHA-256 hash is
        <code>64dee3f69b6e792d1da4fe0ac98fedc7eb1e37ea1027fb609a9fadd06150a4ec</code>
    </p> -->

    <label>
        Game resources file
        <br>
        <input
            accept=".gz.sh"
            type="file"
        />
    </label>

    <br>
    <br>
    <br>
    <p>
        <!-- Let's always have a way to upload full game files
        without downloading demo, in case it goes offline,
        or if other bus shenanigans occur. -->
        Alternatively, if you have already purchased Quake III Arena,
        you can <a href="./upload-full-version.html">upload full game files</a>.
    </p>
</section>

<canvas id=canvas></canvas>

<div id=blocker>
    <div id="move"></div>
    <div id="look"></div>
</div>
<!-- We would like `display: none;`, because when we can't enter
full-screen, this prevents clicking the game. -->
<div id="ui" style="display: none;">
    <div id=multiplayerMessage class="button selected" style=display:none title="COPY MULTIPLAYER URL">COPY MULTIPLAYER URL</div>
    <a id="mainMenuLink" class="button selected" style="display: none;" href="./main-menu.html" title="EXIT TO MAIN MENU">EXIT TO MAIN MENU</a>
</div>
<div id=progress><div id=done></div></div>
</div>
</body>
<script src="compression-streams-polyfill.0.1.7.js"></script>

<script src="./webxdc.js" type="module"></script>

<script src="./override-webrtc.js" type="module"></script>
<script src="./override-websocket-signaling.js" type="module"></script>

<script type='module'>
let peerServer = 's://peer-server.thelongestyard.link';
// if (location.hostname === 'localhost') {
//     peerServer = '://localhost:8080';
// }
const peerServerWebSocket = `ws${peerServer}`;
const peerServerHTTP = `http${peerServer}`;

// HACK: prevent the browser from queueing too many frames. Defeat pipelineing by calling readPixels() after each frame.
// This synchronizes the content process and the GPU process. We don't want to delay finished frames, so we do this just after
// the browser presents the frame. This is achieved by calling postMessage() in RAF. The message will not be processed
// until the frame is presented.
const originalGetContext = HTMLCanvasElement.prototype.getContext;
let context = null;
HTMLCanvasElement.prototype.getContext = function(type, options) {
    return context = originalGetContext.call(this, type, options);
};
const originalRAF = requestAnimationFrame; // save this now in case someone else tries to hook it later, we don't want to use their hooked version for our noop stuff.
const rafChannel = new MessageChannel();
const nopRAF = () => rafChannel.port1.postMessage(' ');
rafChannel.port2.onmessage = ()=>{
    if (context) context.readPixels(0, 0, 1, 1, context.RGBA, context.UNSIGNED_BYTE, new Uint8Array(4));
    originalRAF.call(self, nopRAF);
};
originalRAF.call(self, nopRAF);

// Fool Emscripten into rendering in landscape even on portrait displays.
// TODO: vid_restart if the screen resolution changes.
// TODO: We render at CSS pixel resolution, but should we render at device pixel resolution instead? Maybe that would be needlessly high?
const screenPrototype = Object.getPrototypeOf(screen);
const originalScreenWidthProperty = Object.getOwnPropertyDescriptor(screenPrototype, 'width');
const originalScreenHeightProperty = Object.getOwnPropertyDescriptor(screenPrototype, 'height');
if (screen.height > screen.width) {
    Object.defineProperty(screen, 'width', originalScreenHeightProperty);
    Object.defineProperty(screen, 'height', originalScreenWidthProperty);
}

import { GamepadEmulator } from './GamepadEmulator.js';
const emulator = new GamepadEmulator();
const gamepad = emulator.AddEmulatedGamepad(null, true);
const gamepadEmulatorConfig = {
    directions: { up: true, down: true, left: true, right: true },
    dragDistance: 100,
    tapTarget: move,
    xAxisIndex: 0,
    yAxisIndex: 1,
    swapAxes: false,
    invertX: false,
    invertY: false,
};
emulator.AddDisplayJoystickEventListeners(0, [gamepadEmulatorConfig]);

const rotateGamepad = e => {
    gamepadEmulatorConfig.swapAxes = e.matches;
    gamepadEmulatorConfig.invertX = e.matches;
};
const portraitOrientation = window.matchMedia("(orientation: portrait)");
rotateGamepad(portraitOrientation);
portraitOrientation.addEventListener('change', rotateGamepad);


let lastPointerEvent = null;
let fakeMouseDown = false;

look.addEventListener('pointerdown', (e) => {
    lastPointerEvent = e;
    if (e.offsetY < e.target.clientHeight / 2) {
        fakeMouseDown = true;
        const fakeMouseDownEvent = new MouseEvent('mousedown', {
            clientX: e.offsetX / 2,
            clientY: e.offsetY / 2,
            bubbles: true,
            cancelable: true,
            view: window
        });
        canvas.dispatchEvent(fakeMouseDownEvent);
    }
}, { passive: false });

look.addEventListener('pointermove', (e) => {
    if (lastPointerEvent && lastPointerEvent.pointerId === e.pointerId) {
        let deltaX = e.offsetX - lastPointerEvent.offsetX;
        let deltaY = e.offsetY - lastPointerEvent.offsetY;
        const fakeMouseEvent = new MouseEvent('mousemove', {
            clientX: e.offsetX / 2,
            clientY: e.offsetY / 2,
            movementX: deltaX / 2,
            movementY: deltaY / 2,
            bubbles: true,
            cancelable: true,
            view: window
        });
        // Safari doesn't recognize movementX and movementY, so we have to set them manually.
        if (fakeMouseEvent.movementX === undefined) {
            fakeMouseEvent.movementX = deltaX / 2;
            fakeMouseEvent.movementY = deltaY / 2;
        }

        canvas.dispatchEvent(fakeMouseEvent);
        lastPointerEvent = e;
    }
    e.preventDefault();
}, { passive: false });

look.addEventListener('pointerup', (e) => {
    if (lastPointerEvent && lastPointerEvent.pointerId === e.pointerId) {
        lastPointerEvent = null;
        if (fakeMouseDown) {
            fakeMouseDown = false;
            const fakeMouseUpEvent = new MouseEvent('mouseup', {
                clientX: e.offsetX / 2,
                clientY: e.offsetY / 2,
                bubbles: true,
                cancelable: true,
                view: window
            });
            canvas.dispatchEvent(fakeMouseUpEvent);
        }
    }
}, { passive: false });

look.addEventListener('pointercancel', (e) => {
    if (lastPointerEvent && lastPointerEvent.pointerId === e.pointerId) {
        lastPointerEvent = null;
    }
}, { passive: false });

const originalRequestPointerLock = HTMLElement.prototype.requestPointerLock;
HTMLElement.prototype.originalRequestPointerLock = originalRequestPointerLock;

// Block Emscripten from automatically calling requestPointerLock when we don't want it to.
HTMLElement.prototype.requestPointerLock = function(options) {
    console.log('Intercepted requestPointerLock call');
};



// Don't use fullscreen API on iOS because Apple crippled it. Any touch input with a downward drag will exit fullscreen.
const ios = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

let saveFiles = null;
let lastSavedFilesOnEscapePressAt = Date.now();
/**
 * @param {KeyboardEvent} event
 */
const saveFilesOnEscapePress = (event) => {
    const alreadySavedRecently = (Date.now() - lastSavedFilesOnEscapePressAt) < 1000;
    if (event.key === 'Escape' && !alreadySavedRecently && saveFiles) {
        saveFiles();
        lastSavedFilesOnEscapePressAt = Date.now();
    }
}
document.addEventListener('keydown', saveFilesOnEscapePress, { passive: true });

document.addEventListener('pointerlockchange', ()=>{if (!ios && document.pointerLockElement && !document.fullscreenElement && document.documentElement.requestFullscreen) document.documentElement.requestFullscreen()});
async function canvasRequestPointerLock() {
    try {
        // TODO `requestPointerLock` returns a Promise only on
        // Chromium and Opera,
        // so this code is unreachable on other browsers.
        // We should also listen on the `pointerlockerror` event to fix this.
        await canvas.originalRequestPointerLock({ unadjustedMovement: true });
        return;
    } catch (err) {
        // `unadjustedMovement` is not supported on Linux on Chromium,
        // let's try without this parameter.
        // Aiming will suck, but it's better than nothing.
        //
        // Note that `requestPointerLock` may have failed
        // for a different reason.
        console.warn(
            '`requestPointerLock with `unadjustedMovement: true` failed, falling back to regular',
            err
        );
        await canvas.originalRequestPointerLock();
    }
}
document.addEventListener('fullscreenchange', () => {
    if (saveFiles) saveFiles();
    if (document.fullscreenElement) {
        // This means that full-screen is supported, and we can now save files
        // on 'fullscreenchange', and stop falling back to 'keydown'.
        //
        // Fullscreen is not supported on Delta Chat Tauri as of 2025-05,
        // so we need `saveFilesOnEscapePress`,
        document.removeEventListener('keydown', saveFilesOnEscapePress);
    }
    if (document.fullscreenElement && !document.pointerLockElement && canvas.originalRequestPointerLock) canvasRequestPointerLock();
    ui.style.visibility = document.fullscreenElement ? 'hidden' : 'visible';
});
const fullscreenAndPointerLock = async (e) => {
    if (ui.contains(e.target)) return;
    if (!document.pointerLockElement && canvas.originalRequestPointerLock) canvasRequestPointerLock();
    if (!ios && !document.fullscreenElement && document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
};
blocker.addEventListener('keydown', fullscreenAndPointerLock);
blocker.addEventListener('touchend', fullscreenAndPointerLock);
blocker.addEventListener('mousedown', fullscreenAndPointerLock);
blocker.addEventListener('touchmove', (e) => e.preventDefault() ); // required for touchend to fire if the touch moves

// Prevent Safari from showing a magnifying glass on double tap and hold. C'mon Apple...
blocker.addEventListener('touchstart', e=>e.preventDefault(), {passive: false});
look.addEventListener('touchstart', e=>e.preventDefault(), {passive: false});
move.addEventListener('touchstart', e=>e.preventDefault(), {passive: false});


const defaultKeyBindingKeyCodes = { "KeyW": true, "KeyA": true, "KeyS": true, "KeyD": true, "KeyC": true, "KeyT": true, "Digit1": true, "Digit2": true, "Digit3": true, "Digit4": true, "Digit5": true, "Digit6": true, "Digit7": true, "Digit8": true, "Digit9": true, "Tab": true, "Space": true, "Enter": true, "NumpadEnter": true, "Delete": true, "Slash": true, "Backslash": true, "ArrowUp": true, "ArrowDown": true, "ArrowLeft": true, "ArrowRight": true, "PageDown": true, "End": true, "Escape": true, "ControlLeft": true, "ControlRight": true, "ShiftLeft": true, "ShiftRight": true, "AltLeft": true, "AltRight": true };
window.addEventListener("keydown", (e) => {
        // Emscripten SDL2 will preventDefault all keyboard events which prevents browser keyboard shortcuts from working.
        // This was supposed to be fixed in https://github.com/emscripten-core/emscripten/issues/16462 however the fix regressed.
        // This hack lets the browser handle everything, except for the default Quake III keybindings.
        if (!defaultKeyBindingKeyCodes[e.code]) e.preventDefault = () => false;
    }, { capture: true });

const query = new URLSearchParams(window.location.search);
/** @type {'demoq3' | 'baseq3' | 'openarena-minimal' | string} */
const basegame =
    query.get('basegame') ??
    localStorage.getItem('defaultBasegame') ??
    'demoq3';
// Remember last played game.
// It's important to check `haveFullVersion`,
// because we might have tried to launch the full version
// only because we once tried to connect to a server
// that ran the full version.
// If we don't have the full version, we should not set it as default.
if (!(
    basegame === 'baseq3' &&
    localStorage.getItem('haveFullVersion') !== 'true'
)) {
    localStorage.setItem('defaultBasegame', basegame);
}

/** @type {(files: Array<[filePath: string, file: Promise<Uint8Array>]>}) => void} */
let gotPk3Files;
/** @type {Promise<Array<[filePath: string, file: Promise<Uint8Array>]>}>} */
let pk3FilesPromise = new Promise((resolve) => {
    gotPk3Files = resolve;
});

let username = localStorage.getItem('username');
let model = localStorage.getItem('model');
if (!username || !model) {
    // https://webxdc.org/docs/spec/selfAddr_and_selfName.html
    const webxdcSelfName = globalThis.webxdc?.selfName;
    if (typeof webxdcSelfName === 'string') {
        // Apparently non-ASCII chars don't work well.
        // Also, we want to exclude `"` to avoid command injection.
        const allowedChars =
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
            +" ^[](){}!@#$%&'*+,-./<>=?|";
        const withoutBadCharacters = webxdcSelfName
            .split('')
            .filter(nameCharacter => allowedChars.includes(nameCharacter))
            .join('');
        if (withoutBadCharacters !== webxdcSelfName) {
            console.log(
                '`webxdc.selfName = webxdcSelfName` '
                + 'contains forbidden characters, we filtered them out.'
            );
        }
        if (withoutBadCharacters.trim().length > 0) {
            username = withoutBadCharacters;
        }
    }
    if (!username) {
        username = '';
        const chars = ['bcdfghjklmnprstvwz', 'aeiou'];
        for (let i = 0; i < 6; i++)
            username += chars[i % 2].charAt(Math.random() * chars[i % 2].length | 0);
        username = username.charAt(0).toUpperCase() + username.slice(1);
    }
    localStorage.setItem('username', username);

    const models = basegame === 'baseoa-minimal'
        ? ['sarge']
        : ['sarge', 'visor', 'major', 'major/daemia', 'major', 'major/daemia', 'grunt', 'grunt/stripe']; // only these are available in the demo, plus red/blue versions but those wouldn't be fair
    model = models[Math.random() * models.length | 0];
    localStorage.setItem('model', model);
}


// let server = query.get('server');
let server = 'Myname';
if (query.has('multiplayer')) {
    if (!server) server = username;
    let newUrl = new URL(window.location);
    newUrl.searchParams.delete('multiplayer');
    newUrl.searchParams.set('server', server);
    history.replaceState(null, '', newUrl);
}

let generatedArguments = `
    +set fs_game ${basegame}
`;

let botSkill = 2;

if (window.matchMedia('(pointer: coarse)').matches) {
    // `cl_autoAttack` has been reverted in our fork
    // https://github.com/jdarpinian/ioq3/commit/713c0795c5ea9328111ec2215a077957168f7e2c,
    // because it seems to make the engine .wasm incompatible with other mods.
    // +set cl_autoAttack 1
    generatedArguments += `
        +set g_forcerespawn 2
    `;
} else {
    // generatedArguments += `
    //     +set cl_autoAttack 0
    // `;
}

const knownDemoMaps = [
    'q3dm1',
    'q3dm7',
    'q3dm17',
    'q3tourney2',
];
const fullGameMaps = [
    // 1 through 19. There is also `q3dm0`, but let's skip it.
    ...(new Array(19).fill(0)).map((_, ind) => `q3dm${ind + 1}`),
    // 1 through 6
    ...(new Array(6).fill(0)).map((_, ind) => `q3tourney${ind + 1}`),
    ...(new Array(4).fill(0)).map((_, ind) => `q3ctf${ind + 1}`),
];
/**
 * @param {Array<any>} arr
 */
function randomFromArray(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}
const availableMaps =
    basegame === 'baseq3'
    ? fullGameMaps
    : basegame === 'baseoa-minimal'
    ? ['wrackdm17']
    : knownDemoMaps;
function randomMap() {
    return randomFromArray(availableMaps);
}


let multiplayer = !!server;
if (multiplayer) {
    // Hide in webxdc, "copy link" is pointless there
    //
    // multiplayerMessage.style.display = 'block';
    // ui.style.display = '';
}
multiplayerMessage.addEventListener('click', (e) => {
    navigator.clipboard.writeText(window.location.href);
    multiplayerMessage.innerText = `COPIED! SEND TO YOUR FRIENDS!`;
    multiplayerMessage.title = multiplayerMessage.innerText;
    setTimeout(() => {
        multiplayerMessage.innerText = `COPY MULTIPLAYER URL`;
        multiplayerMessage.title = multiplayerMessage.innerText;
    }, 5000);
    e.preventDefault();
    e.stopPropagation();
}, { capture: true} );

let decideConnectToServer;
let connectToServer = new Promise(r=>decideConnectToServer=r);
if (server) {
    // sanitize to hopefully avoid command injection in autoexec.cfg
    server = server.replace(/"/g, '');
    amITheServerP.then(amITheServer => {
        amITheServer
            ? decideConnectToServer(false)
            : decideConnectToServer(true)
    })
    // fetch(`${peerServerHTTP}/lookup/${server}`).then(r=>r.json()).then((r)=>decideConnectToServer(r.found)).catch(()=>{decideConnectToServer(false);});
}

let buildPath = '.';
if (location.pathname.startsWith('/ioq3/code/web/')) {
    buildPath = '../../build/debug-emscripten-wasm32';
}

// Checking `localStorage` instead of `module.FS`
// because the files could have been deleted by the user manually.
const getFilesAlreadyCreatedStorageKey =
    (basegame) => `filesAlreadyCreated_${basegame}`;
const filesAlreadyCreated =
    localStorage.getItem(getFilesAlreadyCreatedStorageKey(basegame)) === 'true'

const qhome = '/home/web_user/.q3a';

// Fool Emscripten into thinking the browser supports pointer lock.
if (!document.body.requestPointerLock) document.body.requestPointerLock = () => true;

let kickedInitialBots = false;
let firstMainLoop = true;
let shadersCompiled = 0;
let shadersTotal = 57;
let module = null;
import(`${buildPath}/ioquake3_opengl2.wasm32.js`).then(async (ioquake3)=>{
    module = await ioquake3.default({
        canvas: canvas,
        arguments: generatedArguments.trim().split(/\s+/),
        locateFile: (file) => `${buildPath}/${file}`,
        postMainLoop: () => {
            if (firstMainLoop) {
                firstMainLoop = false;
                // SDL is initialized now that the main loop has run for the first time.
                if (window.matchMedia('(pointer: coarse)').matches){
                    // Need to fool Emscripten into believing that pointer lock is enabled so we can send it fake pointer events.
                    Object.defineProperty(document, 'pointerLockElement', { get: () => canvas });

                    const fakePointerLockChangeEvent = new Event('pointerlockchange', {
                        bubbles: true,
                        cancelable: true
                    });
                    document.dispatchEvent(fakePointerLockChangeEvent);
                }
            }
        },
        printErr: (msg) => {
            if (msg === '--- Common Initialization Complete ---') {
                progress.style.display = 'none';
            } else if (msg === '----- Client Shutdown (Client quit) -----') {
                // They pressed "Exit" (close the entire game process).

                // Not sure `saveFiles` will work right before navigation,
                // but why not try
                saveFiles();
                location.assign('./main-menu.html');
            } else if (msg === '==== ShutdownGame ====') {
                // If they didn't quit the entire game,
                // they got to the main menu of the game.
                // Let's enable this link.
                document.getElementById('mainMenuLink').style.display = '';
                // TODO this gonna be a little annoying if we can't enter
                // full screen.
                ui.style.display = '';
            } else if (msg === 'ERROR: Invalid game folder') {
                // This error is usually caused by the server having
                // a demo version, and the client having the full version,
                // or vice versa.
                // Let's change the game version to the one used by the server.
                //
                // TODO but not always!
                //
                // TODO it would be better to check whether the full game
                // is running more "manually".
                // For example, without requiring people to first upload
                // the demo game files.
                //
                // If we already failed previosly, don't try to switch again.
                // TODO this query param is gonna unintentionally
                // persist sometimes, isn't it? When do we want to remove it?
                if (!query.has('reason-invalid-game-folder')) {
                    setTimeout(() => {
                        const newUrl = new URL(location.href);
                        newUrl.searchParams.set('reason-invalid-game-folder', '');
                        // TODO we now have another possible basegame,
                        // `baseoa-minimal`.
                        newUrl.searchParams.set(
                            'basegame',
                            // The current basegame failed, switch to the other one.
                            basegame === 'demoq3' ? 'baseq3' : 'demoq3'
                        );
                        location.assign(newUrl);
                    }, 500);
                }
            } else if (msg?.startsWith('Client') && msg.endsWith('challenge ping')) {
                // "Connected with ... challenge ping"
                // kick all bots when someone connects.
                // FYI there is also `set bot_minplayers`,
                // but it's not great because it will keep the bots
                // until there is enough players,
                // instead of kicking all bots, and will also keep kicking bots
                // even if you added them manually.

                if (!kickedInitialBots) {
                    // I don't know a better way to execute a command.
                    // See https://discourse.ioquake.org/t/how-to-execute-commands-using-another-program-in-web-emscripten-version-stdin/2046
                    window.dispatchEvent(
                        // See below, `bind KP_SLASH`.
                        new KeyboardEvent('keydown', { code: 'NumpadDivide' })
                    );
                    kickedInitialBots = true;
                }
            }
            console.error(msg);
        },
        preRun: [async (module) => {
            document.addEventListener('visibilitychange', () => {
                // Silence audio when the tab is hidden.
                if (document.hidden) {
                    for (const c of Object.values(module.AL.contexts)) {
                        c.gain.gain.linearRampToValueAtTime(0, c.audioCtx.currentTime + 0.1);
                    }
                } else {
                    for (const c of Object.values(module.AL.contexts)) {
                        c.gain.gain.setValueAtTime(0.00001, c.audioCtx.currentTime);
                        c.gain.gain.exponentialRampToValueAtTime(1, c.audioCtx.currentTime + 1);
                    }
                }
            });
            // Add the fetched asset files to the Emscripten virtual filesystem.
            module.addRunDependency('setup-ioq3-filesystem');
            module.FS.mkdirTree(`/${basegame}`);
            module.FS.mkdirTree(qhome);
            module.FS.mount(module.FS.filesystems.IDBFS, {}, qhome);
            let idbfsReadyResolve = null;
            const idbfsReady = new Promise(r=>idbfsReadyResolve=r);
            module.FS.syncfs(true, (err) => {
                if (err) { console.error(err); debugger; }
                idbfsReadyResolve();
            });
            await idbfsReady;
            try {
                // TODO maybe preserve the config when switching
                // between demo and full game?
                if(!module.FS.analyzePath(`${qhome}/${basegame}/q3config.cfg`).exists) {
                    module.arguments.push(...`
                        +set model "${model}"
                        +set headmodel "${model}"
                        +set name "${username}"
                        `.trim().split(/\s+/));
                } else {
                    // Read the existing q3config.cfg and update the name and model in case the user changed them.
                    const q3config = module.FS.readFile(`${qhome}/${basegame}/q3config.cfg`, { encoding: 'utf8' });
                    const lines = q3config.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].startsWith('seta name')) {
                            localStorage.setItem('username', lines[i].split('"')[1]);
                        } else if (lines[i].startsWith('seta model') || lines[i].startsWith('seta headmodel')) {
                            localStorage.setItem('model', lines[i].split('"')[1]);
                        }
                    }
                }
            } catch (err) {
                console.error('Error reading q3config.cfg:', err);
            }

            if (!filesAlreadyCreated) {
                const baseq3aMod = fetch(`${buildPath}/pak8a.pk3`)
                    .then(r => r.arrayBuffer())
                    .then(r => new Uint8Array(r));
                /**
                 * Without this mod the bots in the Quake III Arena demo version
                 * are all running with just gauntlet.
                 */
                const fixDemoBotsMod = fetch(`${buildPath}/pak1-fix-demo-bots.pk3`)
                    .then(r => r.arrayBuffer())
                    .then(b => new Uint8Array(b))
                const ztmFlexibleHudMod = fetch(`${buildPath}/ztm-flexible-hud.pk3`)
                    .then(r => r.arrayBuffer())
                    .then(r => new Uint8Array(r));

                writeCommonPersistentFiles(module, basegame);

                module.FS.mkdirTree(`${qhome}/${basegame}`);
                // The Quake SDK license, which baseq3a is under,
                // apparently does not allow to use the mod with games
                // other than full Quake III Arena.
                // - https://github.com/ec-/baseq3a/blob/master/QIIIA%20Game%20Source%20License.txt
                // - https://openarena.fandom.com/wiki/Mod_compatibility
                // > for operation only with the full version
                // > of the software game QUAKE III ARENA
                //
                // For the demo version, we have to provide QVMs,
                // because the ones in the demo's `pak0.pk3`
                // are not compatible with the new engine.
                // So we choose ztm-flexible-hud for that,
                // as in the original thelongestyard.link project.
                if (basegame === 'baseq3') {
                    module.FS.writeFile(
                        `${qhome}/${basegame}/pak8a.pk3`,
                        await baseq3aMod
                    );
                } else if (basegame === 'demoq3') {
                    // TODO use a mod that includes the "Unlagged" mod.
                    // https://www.ra.is/unlagged/
                    // baseq3a does, but, as we said above, we can't use it
                    // with the demo version.
                    module.FS.writeFile(
                        `${qhome}/${basegame}/ztm-flexible-hud.pk3`,
                        await ztmFlexibleHudMod
                    );
                    module.FS.writeFile(
                        `${qhome}/${basegame}/pak1-fix-demo-bots.pk3`,
                        await fixDemoBotsMod
                    );
                }
            }

            // Initialize Open Arena mod regardless of whether `basegame`
            // is Open Arena or Demo or whatever,
            // so that if the server is running Open Arena,
            // the engine can auto-switch to it
            // without spitting out the "Invalid game folder" error
            // in case that this user has never launched Open Arena.
            const BASEGAME_BASEOA_MIN = 'baseoa-minimal'
            if (localStorage.getItem(getFilesAlreadyCreatedStorageKey(BASEGAME_BASEOA_MIN)) !== 'true') {
                const baseoa = fetch(`${buildPath}/openarena-minimal.pk3`)
                    .then(r => r.arrayBuffer())
                    .then(r => new Uint8Array(r));

                module.FS.mkdirTree(`${qhome}/${BASEGAME_BASEOA_MIN}`);
                writeCommonPersistentFiles(module, BASEGAME_BASEOA_MIN);
                module.FS.writeFile(
                    `${qhome}/${BASEGAME_BASEOA_MIN}/openarena-minimal.pk3`,
                    await baseoa
                );
                localStorage.setItem(getFilesAlreadyCreatedStorageKey(BASEGAME_BASEOA_MIN), 'true');
            }

            const pk3Files = await pk3FilesPromise;
            await Promise.all(pk3Files.map(async ([filePath, file]) => {
                module.FS.writeFile(filePath, await file);
            }));

            // Clean them up from RAM
            // I don't know why, but dev tools report that
            // even if we set `pk3FilesPromise = undefined`,
            // the array is still retained in `Generator` of this module
            // somehow. So let's also empty the array.
            pk3Files.fill(undefined);
            pk3FilesPromise = undefined;
            gotPk3Files = undefined;

            saveFiles = () => {
                module.FS.syncfs(false, (err) => {
                    if (err) { console.error(err); debugger; }
                });
            };
            saveFiles();

            if (multiplayer) {
                const tryNotifyChat = (message) => {
                    const selfName = globalThis.webxdc?.selfName || 'A player'
                    // https://webxdc.org/docs/spec/sendUpdate.html
                    globalThis.webxdc?.sendUpdate?.({
                        payload: null,
                        // TODO feat: add the current number of players
                        // to `summary`? Will need to handle disconnects though.
                        info: `${selfName} ${message}`,
                    }, '')
                }

                if (await connectToServer) {
                    module.arguments.push(...`
                        +set net_peer_server "${peerServerWebSocket}"
                        +connect "${server}.humblenet"
                    `.trim().split(/\s+/));

                    // Only after a timeout, so that we can collect
                    // some packets to determine the current number of players
                    // (`globalThis.addressToLastPacketTimestamp`).
                    // The delay doesn't have to be big,
                    // because this code runs after we've already been able
                    // to receive some packets
                    // (because at this point we have determined
                    // who the server is).
                    // Note, however, that if we're the first to join,
                    // then we won't receive packets from the server
                    // until we have sent some ourself.
                    setTimeout(async () => {
                        // Just ourself and the server for now.
                        let numPlayers = 2;
                        const serverAdress = await globalThis.serverAddressP;
                        /** @type {Map<number, number>} */
                        const map = globalThis.addressToLastPacketTimestamp;
                        map.forEach((lastPacketReceivedAt, address) => {
                            if (address === serverAdress) {
                                // We've already counted the server.
                                return
                            }
                            // Ignore incorrectly counted special packets
                            // (see `isWhoIsTheServerRequest`,
                            // `isWhoIsTheServerResponse`).
                            // Yes, this is stupid.
                            if (address === 0x2B2B2B2B || address === 0x2A2A2A2A) {
                                return
                            }
                            if (Date.now() - lastPacketReceivedAt < 5000) {
                                numPlayers += 1;
                            }
                        });
                        // FYI the "entered the game" part is the same
                        // as the respective in-game message.
                        tryNotifyChat(
                            `entered the game. Players online: ${numPlayers}`
                        );
                    }, 1000)
                } else {
                    // TODO improvement: in the full game there are more bots
                    // to choose from.
                    // Unfortunately `addbot random` is not available
                    // in baseq3a mod.
                    // For demoq3 we use ztm-flexible-hud mod,
                    // which has support for `random` bot.
                    //
                    // `+exec setNextmap.cfg` seems to be needed because
                    // map rotation seems to be broken by `+map ...`.
                    // Otherwise `nextmap` is set to `map_restart 0`,
                    // despite it being present in `autoexec.cfg`.
                    const bots =
                        basegame === 'demoq3'
                        ? ['random', 'random', 'random', 'random']
                        : basegame === 'baseq3'
                        ? ['sarge', 'daemia', 'visor', 'stripe']
                        : basegame === 'baseoa-minimal'
                        ? ['sarge', 'sarge', 'grism', 'grism']
                        : ['sarge', 'sarge', 'sarge', 'sarge']
                    module.arguments.push(...`
                        +set net_peer_server "${peerServerWebSocket}"
                        +set net_server_name "${server}"
                        +map ${randomMap()}
                        ${bots.map(b => `+addbot ${b} ${botSkill}`).join(' ')}
                        +exec setNextmap.cfg
                        `.trim().split(/\s+/));

                    // Only after a timeout so as to be less annoying,
                    // e.g. when someone opens the app just to check
                    // if anyone is online, or just to fiddle around.
                    //
                    // TODO fix: though the messages might look a bit stupid
                    // if someone joins before we've sent this message.
                    setTimeout(() => {
                        tryNotifyChat('started the server');

                        // This is so that you don't enter the chat to see
                        // that someone has started the server
                        // only to open the game and realize that it's
                        // already finished.
                        //
                        // Yes, `pagehide` might not work on mobile,
                        // but `visibilitychange` is kind of worse on Desktop
                        // because of false-positives.
                        // `window.top` because see
                        // https://github.com/deltachat/deltachat-desktop/issues/3321#issuecomment-1821024467.
                        window.top.addEventListener('pagehide', () => {
                            tryNotifyChat('stopped the server');
                        });
                    }, 10 * 1000)
                }
            } else {
                module.arguments.push(...`
                    +map ${randomMap()}
                    +addbot sarge ${botSkill}
                    +addbot daemia ${botSkill}
                    +addbot major ${botSkill}
                    +addbot visor ${botSkill}
                    +addbot stripe ${botSkill}
                    +exec setNextmap.cfg
                `.trim().split(/\s+/));
            }
            module.FS.writeFile(`/${basegame}/autoexec_2_autogenerated.cfg`, `
                // Map rotation. After a match has finished,
                // go to next map.
                // Taken from
                // https://planetquake.gamespy.com/View110c.html?view=Guides.Detail&id=52&game=4
                // https://guides.gamehostbros.com/games/quake-3/mapcycle/
                ${availableMaps
                    // Shuffle
                    .map(mapName => ({ mapName, sortVal: Math.random() }))
                    .sort((a, b) => a.sortVal - b.sortVal)
                    .map(obj => obj.mapName)

                    .map((mapName, ind, arr) => {
                        const nextInd = ind === arr.length - 1
                            ? 1
                            : ind + 2;
                        return `set d${ind + 1} "map ${mapName} ; set nextmap vstr d${nextInd}"`
                    })
                    .join('\n')}
                // vstr d1
                set nextmap vstr d1

                    `, { encoding: 'utf8' });
            module.removeRunDependency('setup-ioq3-filesystem');
            localStorage.setItem(getFilesAlreadyCreatedStorageKey(basegame), 'true');
        }],
    });
    if (multiplayer) {
        // Always run server even in background tabs.
        // Workers are not subject to setTimeout/setInterval throttling in background tabs and they can postMessage to wake the main thread.
        // This will render too which is unfortunate but whatever.
        // Probably doesn't work on mobile. I guess it's fine.
        const worker = new Worker(URL.createObjectURL(new Blob([`
            setInterval(() => {
                self.postMessage('tick');
            }, 1000 / 60);
        `], { type: 'application/javascript' })));
        worker.onmessage = function(e) {
            if (document.hidden && module && module.Browser && module.Browser.mainLoop)
                module.Browser.mainLoop.runIter(module.Browser.mainLoop.func);
        };
    }
});

// demoq3/pak0.pk3 is original Quake 3 demo assets. Fetch them from a tarfile in a gz file in a shell script in a zip file at the Internet Archive.
// First check to see if we have it in the cache
if (filesAlreadyCreated) {
    gotPk3Files([])
    done.style.transform = 'scaleX(1)';
} else {
    if (basegame === 'demoq3') {
        const filePickerSection = document.getElementById('upload-game-files');
        filePickerSection.style.display = '';
        const bodyInitialOverflow = document.body.style.overflow;
        const rotator = document.getElementById('rotator');
        const rotatorInitialOverflow = rotator.style.overflow;
        // This is especially useful on mobile.
        document.body.style.overflow = 'auto';
        rotator.style.overflow = 'auto';
        const filePicker = filePickerSection.getElementsByTagName('input')[0];
        const blockerEl = document.getElementById('blocker');
        const progressEl = document.getElementById('progress');
        blockerEl.style.display = 'none';
        progressEl.style.display = 'none';
        canvas.style.display = 'none';
        await new Promise(r => {
            filePicker.onchange = r;
        })
        blockerEl.style.display = '';
        progressEl.style.display = '';
        canvas.style.display = '';
        filePickerSection.remove();
        document.body.style.overflow = bodyInitialOverflow;
        rotator.style.overflow = rotatorInitialOverflow;

        const demoSize = 49289300;
        // let sh = await fetch('https://archive.org/download/tucows_286139_Quake_III_Arena/linuxq3ademo-1.11-6.x86.gz.zip/linuxq3ademo-1.11-6.x86.gz.sh').then(r => r.body);
        let sh = filePicker.files[0].stream();
        // Skip the first 0x155C bytes of the shell script to get the gz file. Ugh, the streams API is terrible.
        // Also update the progress bar.
        let downloaded = 0;
        let gz = sh.pipeThrough(new TransformStream({
            transform(chunk, controller) {
                const skip = 0x155C;
                if (downloaded >= skip) {
                    downloaded += chunk.byteLength;
                    done.style.transform = `scaleX(${downloaded / demoSize * .6 + .2})`;
                    controller.enqueue(chunk);
                    return;
                }
                const chunkStart = downloaded;
                const chunkEnd = downloaded + chunk.byteLength;
                downloaded = chunkEnd;
                if (chunkEnd < skip) return;
                controller.enqueue(chunk.subarray(skip - chunkStart));
                done.style.transform = `scaleX(${downloaded / demoSize * .6 + .2})`;
                if (downloaded === demoSize) {
                    done.style.transform = 'scaleX(1)';
                }
            }
        }));
        let tar = new Uint8Array(await new Response(gz.pipeThrough(new DecompressionStream('gzip'))).arrayBuffer());
        // the tar format is structured in 512 byte blocks. Read the blocks and find the pak0.pk3 file
        for (let offset = 0; offset < tar.byteLength;) {
            let name = String.fromCharCode.apply(null, tar.subarray(offset, offset + 100)).replace(/\0/g, '').trim();
            let size = parseInt(String.fromCharCode.apply(null, tar.subarray(offset + 124, offset + 136)).replace(/\0/g, '').trim(), 8);
            if (name === 'demoq3/pak0.pk3') {
                const demoq3pak0 = tar.subarray(offset + 512, offset + 512 + size);
                gotPk3Files([
                    [`${qhome}/demoq3/pak0.pk3`, Promise.resolve(demoq3pak0)]
                ]);
                break;
            }
            offset += 512 + Math.ceil(size / 512) * 512;
        }
    } else if (basegame === 'baseq3') {
        if (localStorage.getItem('haveFullVersion') !== 'true') {
            // Preserve query parameters, such as `server`,
            // so that that page knows where to return to.
            const nextUrl = new URL(location.href);
            nextUrl.pathname = './upload-full-version.html';
            nextUrl.hash = 'go-back-on-success';
            location.assign(nextUrl);
        } else {
            // The files have already been added to the FS
            // by `upload-full-version.html`.
            gotPk3Files([]);
            done.style.transform = 'scaleX(1)';
        }
    } else {
        gotPk3Files([]);
        done.style.transform = 'scaleX(1)';
    }
}

/**
 * @param {string} basegame
 */
function writeCommonPersistentFiles(module, basegame) {
    module.FS.mkdirTree(`${qhome}/${basegame}`);
    module.FS.writeFile(`${qhome}/${basegame}/autoexec.cfg`,
`set in_joystick 1
set in_joystickUseAnalog 1
set j_forward "0.005"
set j_side "0.005"
set j_pitch "0.005"
set j_yaw "0.01"
bind PAD0_LEFTSTICK_LEFT "+moveleft"
bind PAD0_LEFTSTICK_RIGHT "+moveright"
bind PAD0_LEFTSTICK_UP "+forward"
bind PAD0_LEFTSTICK_DOWN "+back"
bind PAD0_DPAD_LEFT "+moveleft"
bind PAD0_DPAD_UP "+forward"
bind PAD0_DPAD_RIGHT "+moveright"
bind PAD0_DPAD_DOWN "+back"
bind PAD0_RIGHTSTICK_LEFT "+left"
bind PAD0_RIGHTSTICK_RIGHT "+right"
bind PAD0_RIGHTSTICK_UP "+lookup"
bind PAD0_RIGHTSTICK_DOWN "+lookdown"
bind PAD0_RIGHTTRIGGER "+attack"
bind PAD0_LEFTTRIGGER "+zoom"
bind PAD0_A "+moveup"
bind PAD0_B "weapnext"
bind PAD0_X "weapprev"
bind PAD0_Y "weapon 1"
bind PAD0_LEFTSHOULDER "+zoom"
bind PAD0_RIGHTSHOULDER "+attack"
bind PAD0_START "togglemenu"
bind PAD0_BACK "+button3"
bind PAD0_LEFTSTICK_CLICK "+zoom"
bind PAD0_RIGHTSTICK_CLICK "+button3"

// "ESCAPE" conflicts with "exit fullscreen",
// which is rather annoying,
// so maybe this will be of use to some people.
bind F4 "togglemenu"

// By default F11 is "screenshot", but firstly,
// they turn out to be just all black in the web version.
// Secondly they're not accessible by regular users
// and thus just waste storage.
// Also, F11 is associated with "full screen".
unbind F11

// "map_restart" with no delay, so as to not induce
// "try hard" feelings in players.
// "map_restart 0" seems to break map rotation
// by assigning to "nextmap" var, so we manually set it again.
bind KP_SLASH "kickbots; map_restart 0; set nextmap vstr d1; unbind KP_SLASH"

// https://github.com/ec-/baseq3a/pull/53
// Only applies when pak8a.pk3 mod is present (not in the demo version).
set cg_oldGibs 0

set r_mode -2 // make game use desktop resolution

${
// No need for "very high quality" on a game with all models and textures
// compressed to bare minimum.
basegame !== 'baseoa-minimal'
?
`set r_picmip 0 // full texture detail
set r_lodBias -2 // don't use lower detail models far away
set r_subdivisions 1 // smoother curves
set r_textureMode "GL_LINEAR_MIPMAP_LINEAR" // trilinear filter
set r_ext_texture_filter_anisotropic 1 // enable anisotropy texture filter
set r_ext_max_anisotropy 16 // 16x anisotropy texture filter
set r_ext_multisample 16 // use multisample antialiasing
set r_ext_framebuffer_multisample 16 // use multisample antialiasing
set r_lodCurveError 10000 // smoother curves far away (cheat protected)`
: ''
}

set g_warmup 0 // baseq3a mod has it set to 20 by default. But we're casual here.
set r_mode -2
set cg_fovAdjust 1
// These two are from ztm-flexible-hud mod.
set cg_fovGunAdjust 1
set cg_fovAspectAdjust 1
set com_maxfps 0
set r_swapInverval 1
set net_enabled 1
set r_fullscreen 0
set r_ignoreGLErrors 1
set cg_fov 90
set cg_deferPlayers 0 // load player models when they connect instead of substituting a random model

// These are present in thelongestyard.link, but the Unlagged mod creator
// Doesn't recommend to set a higher value of \`sv_fps\`.
// https://www.ra.is/unlagged/
// Also since, again, WebXDC connection is reliable, sending more packets
// might make things more messy (but I'm not sure).
// set sv_fps 60
// set snaps 60
// set cl_maxpackets 125

set sv_maxclients 128

${globalThis.webxdc != undefined
    ? (
        '// webxdc connection is reliable + ordered as of 2025-05,\n' +
        '// so duplicating packets is of no use.\n' +
        'set cl_packetdup 0\n'
    ) : ''
}

set sv_pure 1

// The autoexec_2_autogenerated.cfg file's content is auto-generated
// on each launch. The file includes randomized map rotation.
// In the future it might include other things.
// So you probably don't want to remove this line.
exec autoexec_2_autogenerated.cfg
`, { encoding: 'utf8' });

    module.FS.mkdirTree(`${qhome}/${basegame}`);
    module.FS.writeFile(
        `${qhome}/${basegame}/setNextmap.cfg`,
`// This file is executed when the game is launched.
// Without it the map rotation seems to be broken.
// Otherwise \`nextmap\` is set to \`map_restart 0\`,
// despite it being present in \`autoexec.cfg\`.
set nextmap vstr d1`,
        { encoding: 'utf8' }
    )
}

</script>
